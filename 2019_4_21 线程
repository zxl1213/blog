多线程:
	线程概念
	线程控制:线程控制,线程终止,线程等待,线程分离
	线程安全
	同步与互斥:互斥锁,条件变量,(生产者与消费者模型),posix标准信号量,读写锁(读写者模型)
	线程池:理解与基本实现
	设计模式:线程安全的单例模式
线程概念: 
	linux下pc是线程;
	因为linux下线程以进程的pcb模拟实现线程,因此linux下pcb是线程,也叫轻量级进程
	因为linux线程是pcb----因此线程是cpu调度的基本单位
	因为进程是线程组---程序运行起来,资源是分配给整个进程组的,因此进程是资源分配的基本单位
	多进程可以并行多任务,多线程也可以并行多任务,用哪个好?
	优缺点对比:
		一个进程中的线程共用同一个虚拟地址空间
		线程间通信更加方便
		线程的创建/销毁成本更低
		线程间调度切换成本更低
		线程的执行粒度更细
		
		线程间缺乏访问控制----系统调用(exit),异常针对整个进程,健壮性低
    多进程/多线程进行多任务处理的优势体现和细节:
		cpu密集型程序
		io密集型程序
	vfork创建一个子进程共用同一个虚拟地址空间,怕调用栈混乱,因此子进程运行完毕或程序替换后父进程才运行
	多线程使用同一个虚拟地址空间:如何实现同时运行而不会出现调用栈混乱
		为每个线程在虚拟地址空间中单独分配一块空间
		每个线程都会有一些独立的信息
			栈
			寄存器(上下文数据)
			errno
			信号屏蔽字()
			调度优先级
		线程之间共享的数据:
			代码段,数据段
			文件描述符表
			每种信号的处理方式
			用户id组id,当前工作路径
线程控制:线程控制,线程终止,线程等待,线程分离
	操作系统并没有为用户提供直接创建线程的系统调用接口,因此大佬们就自己封装了一套线程库实现线程控制
	因此有人称我们自己创建的线程为用户态线程,在内核中对应了一个轻量级进程实现程序的调度运行
	pthread_create -lmytest
	pthread.h 因为是库函数,因此编译链接是需要加上-pthread/-lpthread链接线程库
	ps -L 查看轻量级进程(线程)信息
	tid                          task_struct-pid   task_struct_tgid
	线程地址空间首地址           LWP               PID=主线程的id
进程终止:
	在线程入口函数中return
	pthread_exit 退出调用线程
		主线程退出,进程不会退出
		线程退出也会成为僵尸线程(但普通线程体现不出效果)
		线程地址空间无法被回收再利用,造成内存泄漏
	pthread_cancel 取消一个指定的线程
线程等待:获取指定线程的返回值,允许系统回收资源
	一个线程运行起来,默认有一个属性:joinable;这个属性决定了线程退出后,必须能够被等待,
	因为线程退出后,为了保证退出返回值,不会自动回收线程的资源(成为僵尸进程) 
	线程等待有一个前提:线程能够被等待
	使用pthread_join接口实现线程等待,获取指定线程返回值,允许系统释放资源
线程分离:将线程的一个属性从joinable设置为detach属性
	处于detach属性的线程,退出后资源直接自动回收,这类线程不能被等待
	用法:如果用户对线程的返回值并不关心,则在创建进程之后直接分离线程或者在线程入口函数中第一时间分离自己
	pthread_detach(pthread_t tid)
线程安全:

