课后调研:一个线程被取消,返回值是多少
线程安全:多个线程同时操作临界资源而不会出现数据二义性
		在线程中是否对临界资源进行了非原子操作
	可重入/不可重入:多个执行流中是否可以同时进入函数运行而不出现问题
	实现线程安全:
		同步:临界资源的合理访问
		互斥:临界资源同一时间唯一访问性
	互斥如何实现:
		互斥锁:如何实现安全操作?  1/0
		一个0/1的计数器---
			1表示可以加锁,加锁就是计数-1;
			操作完毕之后要解锁,解锁就是计数+1
			0表示不可以加锁,不能加锁则等待
			互斥锁操作步骤:
				1.定义互斥锁变量   pthread_mutex_t
				2.初始化互斥锁变量 pthread_mutex_init
				3.加锁             pthread_mutex_lock
				4.解锁             pthread_mutex_unlock
 				5.销毁互斥锁       pthread_mutex_destory
			死锁:因为对一些无法加锁的程序加锁而导致程序卡死
				产生的四个必要条件:
					1.互斥条件:我操作的时候别人不能操作
					2.不可剥夺条件:我的锁,我的锁别人不能解
					3.请求与保持条件:拿着手里的,请求其他的,其他的请求不到,手里的也不放
					4.环路等待条件
				产生场景:加锁/解锁顺序不同
				预防死锁:破坏必要条件
				避免死锁:死锁检测算法/银行家算法--课后调研
				死锁处理:银行家算法
	同步如何实现(唤醒与等待---条件变量):临界资源访问合理性---生产出来才能使用
		没有资源则等待(死等),生成资源后唤醒等待
		线程1如果操作条件满足,则操作,否则进行等待
		线程2促使条件满足,唤醒等待的线程
		条件变量:
			1.定义条件变量     pthead_cond_t
			2.初始化条件变量   pthead_cond_init
			3.等待或者唤醒     pthead_cond_wait/pthead_cond_signal
			4.销毁条件变量     pthead_cond_init


















